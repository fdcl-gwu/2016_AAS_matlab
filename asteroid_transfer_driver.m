% 20 July 2016
% ASTEROID TRANSFER DRIVER - big function to automate the shooting process
clc
close all
clearvars
%% ASTEROID CONSTANTS
constants = load_constants('castalia','true'); % only 1024 faces
asteroid_grav = polyhedron_shape_input(constants);
constants.asteroid_grav = asteroid_grav;

constants.pot_model = 'polyhedron'; % or mascon or matlab

constants.ode_options = odeset('RelTol',1e-9,'AbsTol',1e-9);
constants.optfsolve = optimoptions(@fsolve,'Display','off','TolFun',1e-5,'TolX',1e-9,...
    'MaxIter',5000,'MaxFunEvals',5000, 'Algorithm', 'trust-region-reflective','Jacobian','off',...
    'DerivativeCheck','off', 'FunValCheck','on');

num_steps = 1000;
constants.num_steps = num_steps;
constants.num_seg = 2; % number of segments for multiple shooting

% DEFINE CENTER OF ROTATION FOR POINCARE CUT
% angles to define the poincare section
constants.center_vec = zeros(3,1);
constants.pmap = [1 3 4 6]; % Indices of Poincare map

% THINGS TO CHANGE
constants.um = 1e-7; % 0.4e-7 to 12e-7 for 20-600 mN electric thrusters on 500 kg spacecraft
constants.num_angles = 10; % discretization of Poincare section

constants.filename = 'first_stage.mat';
%% INITIALIZE TRANSFER
% this generates the initial and desired orbits (not any of the
% subintervals)
fprintf('INITIALIZE TRANSFER\n');

% constants.control_switch = 'off';
% [t_initial,state_initial,t_target,state_target]=initialize_transfer(constants);

load('./results/initial_transfer2.mat');
% 
% tf = t_initial(end);
% xcf = state_initial(end,1:6)';
% 
% % INITIAL GUESS OF COSTATE AND LAGRANGE MULTIPLIERS
% x0_i = state_initial(end,:)';
% h0_i = 1e-3*ones(6,1);
% beta_i = 1e-3*ones(4,1);

% % first stage end
% 
% x0_i =[1.498401068822132;...
%    0.000611561345735;...
%    0.011583474695990;...
%   -0.000010026739860;...
%   -0.000941566348072;...
%    0.000055723466536];
% h0_i =[-0.000781020357150;...
%    0.001099045598955;...
%   -0.000979014128534;...
%   -0.100206158650966;...
%   -0.002280957497598;...
%   -0.000884747392517];
% beta_i =[0.100000000000000;...
%    0.399771935051176;...
%    0.089795765093678;...
%    0.100025455810991];
% tf = 1.067722230391617e+04;
% xcf =[2.077159528721681;-0.000000000000087;0.378791359090794;0.000089748179063;-0.001104988468142;0.000007938853345];

% % second stage end
% x0_i =[2.077795891228278;...
%   -0.000004871470636;...
%    0.360187781845660;...
%    0.000127576838231;...
%   -0.001163671452053;...
%    0.000009983154785];
% h0_i =[-0.001278288527103;...
%   -0.000646473349550;...
%    0.000885902708142;...
%   -0.100169461720130;...
%   -0.000006898322536;...
%   -0.000000013821624];
% beta_i =[0.100000000000000;...
%    0.474186783247932;...
%    0.100000000000000;...
%    0.100164151486289];
% tf = 1.265092480663672e+04;
% xcf = [4.112253489269687;-0.000000000000000;0.321672258746572;0.000166442267871;-0.001900885925300;-0.000009288866855];
% 
% % third stage end
% x0_i =[4.111376105492149;...
%   -0.000000044309091;...
%    0.323379841111232;...
%    0.000162769777590;...
%   -0.001769352835246;...
%    0.000099237091862];
% h0_i =[0.001311011561592;...
%   -0.000604278918249;...
%   -0.000863337162019;...
%   -0.099902850824751;...
%   -0.000000309033528;...
%   -0.000055000368593];
% beta_i =[0.100000000000000;...
%    2.112864784317537;...
%    0.100000000000000;...
%    0.099905507558778];
% tf = 1.461787703811157e+04;
% xcf =[6.066683058109329;-0.000000000000297;1.710089438879126;0.000112211225736;-0.002605787256505;0.000090140245009];

% % fourth stage end
% x0_i =[6.067392350071479;...
%   -0.000006168290377;...
%    1.672353613002382;...
%    0.000036642243703;...
%   -0.002724784403780;...
%    0.000032568294619];
% h0_i =[-0.001298580111403;...
%    0.000513263598639;...
%    0.000835624843087;...
%   -0.156785519515781;...
%    0.000115133897927;...
%   -0.000529497814863];
% beta_i =[0.100000000000000;...
%    0.419346783021145;...
%   -0.217665639788219;...
%    0.156527612425489];
% tf = 1.404166904369141e+04;
% xcf =[6.599194668731970;-0.000000000000001;2.068832600847796;0.000038762350675;-0.002942927985583;0.000024007939999];

% fifth stage end
x0_i =[6.598101413945767;...
  -0.000000270840723;...
   2.069541897911115;...
   0.000137435755806;...
  -0.002800731805826;...
   0.000152726588220];
h0_i =[0.001091885458360;...
  -0.000937847493655;...
  -0.000829463978428;...
  -0.100093150716599;...
  -0.000002999315496;...
  -0.000096631388151];
beta_i =[0.100000000000000;...
   0.100000000000000;...
   0.083972106364423;...
   0.100021144557387];
tf = 1.476798521971358e+04; % from stage 4
xcf =[8.478950779885199;-0.000000000000411;4.264670864487190;0.000119376890115;-0.003613658748486;0.000144869430777];

%% CALL THE SHOOTING METHOD

% [sol_output] = asteroid_shooting(x0_i,h0_i,beta_i,xcf,tf,constants);
% load('./results/coarse_asteroid_1.mat')
% load('./results/hpc_stage_1/fine_asteroid_1_18_um1e-7.mat')

% second stage results
% load('./results/hpc_stage_2/hpc_stage2_um1e-7.mat')

% third stage results
% load('./results/hpc_stage_3/hpc_stage3_um1e-7.mat')

% fourth stage results
% load('./results/hpc_stage_4/hpc_stage4_um1e-7.mat')

% fifth stage results
load('./results/hpc_stage_5/hpc_stage5_um1e-7.mat')
%% DETERMINE THE CLOSEST REACH STATE

[min_reach,reach_struct] = minimum_reach(sol_output,state_target(1,:), 'min_dist');

% do some optional plotting
plot_output(sol_output,reach_struct,min_reach);
%% INITIALIZE NEXT STAGE

% periodic orbit near the final state from the previous asteroid shooting
% constants.periodic_diffcorr_section = 'x_axis';
% constants.diffcorr_plot=1;
% [x0_out, cross_time_out, phi_cross_out,monodromy_matrix] = periodic_orbit_diffcorr(min_reach.xf(1:6)',constants);

% propogate the minimum orbit with no control and find the next positive x
% axis crossing

constants.periodic_diffcorr_section = 'x_axis';
options_cross = odeset('RelTol',constants.RelTol,'AbsTol',constants.AbsTol,'Events',@(t,x)events_xcross(t,x,constants));
num_steps = constants.num_steps;
[t,state,cross_t,cross_state,ie] = ode113(@(t,state)ast_eoms(t,state,constants),linspace(0,30000,constants.num_steps),min_reach.xf(1:6),options_cross);

% plot this orbit to visualize it
traj_fig = figure();
grid on
hold all
vertex_plotter(sol_output(1).constants.F,sol_output(1).constants.V,traj_fig);
plot3(state(:,1),state(:,2),state(:,3),'k')

% define the input data for the next stage
x0_i = min_reach.traj(end,:)';
h0_i = min_reach.costate(end,:)';
beta_i = sol_output(min_reach.index).beta;
tf = cross_t(end,:);
xcf = cross_state(end,:);
% call asteroid shooting again
% need to define x0_i, h0_i, beta_i, xcf,tf
